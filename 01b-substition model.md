在第2章中，作者谈到了意外一些问题：为什么要理解substitution model：这里作者打了一个比方：作者在学摄影的时候，学到了一点：如果想要成为一个好的摄影师，那么就不应该仅仅知道如何按键，实际上，更重要的是，按键之后，相机内部会如何呈现现在的画面，而这，就要求摄影师深入底层去做一些脏活，如洗胶片。在这里，如果一个程序员想要编好程序，那么他还应该明白当程序写出来之后，计算机是如何处理程序中的命令的。
substitution model 并不完完全全是指令在计算机内部的运算过程，它只是一个近似的过程，但是这并不因为就要抛弃它。我们仍然可以通过这种近似获得知识。
特点：先处理操作符(operator)，然后是操作数（operand）,这里要注意了2点：
1. 操作数的evaluation过程，是从右向左，例如,`(define ( + 8 9))`中，在操作符+ 之后，随后evaluate的，是9，而不是8。
2. 递归evaluate:如 `(define  + (+ 8 9) (* 9 (* 9 9）））`其中，后一个需要不断递归evaluate，因此(+ 8 9)需要等待。

作者给出的如下：
1. Evaluate the operator
2. Evaluate the operand
3. Apply
 
本节中引入了新的规则：if : `(define  a (if (< 7 1)  1 7)))`
另外，作者在本节中区分了iteration 与recursion ，并通过实例演示了汉诺塔，加法的迭代与递归操作区别。作者还介绍了斐波那契数列的实现，并引出了时间复杂度的计算。这便是主要内容。
在第三章可以看到，在引入副作用(side-effects)后,substitution model就不再适用了。
另外，还有一点，是applicative model 以及 **remain to be done** model，在这里，关键是他们有什么特别的不同？一个是先不断展开，直到不能展开位置，然后在evaluate，另一个，则是尽量evaluate，实在不行了再处理别的。如